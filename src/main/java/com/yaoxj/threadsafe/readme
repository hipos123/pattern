https://www.cnblogs.com/rainie-love/p/8531667.html

线程安全问题
1.产生原因
我们使用java多线程的时候，最让我们头疼的莫过于多线程引起的线程安全问题，那么线程安全问题到底是如何产生的呢？究其本质，
是因为多条线程操作同一数据的过程中，破坏了数据的原子性。所谓原子性，就是不可再分性。有物理常识的小伙伴可能要反驳了，
谁说原子不可再分？原子里边还有质子和中子。我们不在这里探讨物理问题，我确实也没深究过为什么被称为原子性，
也许是这个原则出现的时候还没有发现质子和中子，我们只要记住在编程中所提到的原子性指的是不可再分性就好了。回到正题，
为什么说破坏了数据的原子性就会产生的线程安全问题呢？我们用一个非常简单的例子来说明这个问题。
　
我们来看下面这段非常简单的代码：
int i = 1;
int temp;

while(i < 10){
temp = i; //读取i的值
i = temp + 1; //对i进行+1操作后再重新赋给i
};
细心的小伙伴可能已经发现了，这不就是i++做的事情吗。没错，其实i++就是做了上面的两件事：
读取i当前的值
对读取到的值加1然后再赋给i
　　
我们知道，在某一个时间点，系统中只会有一条线程去执行任务，下一时间点有可能又会切换为其他线程去执行任务，
我们无法预测某一时刻究竟是哪条线程被执行，这是由CPU来统一调度的。因此现在假设我们有t1、t2两条线程同时去执行这段代码。
假设t1执行完第5行代码停住了（需要等待CPU下次调度才能继续向下执行），此时t1读到i的值是1。然后CPU让t2执行，注意刚才t1只执行完了第5行，
也就是说t1并没有对i进行加1操作然后再赋回给i，因此这是i的值还是1，t2拿到i=1后一路向下执行直到结束，当执行到第6行的时候对i进行加1并赋回给i，
完成后i的值变为2。好了，此时CPU又调度t1让其继续执行，重点在这里，还记不记得t1暂停前读取到的i是几？没错是1，此时t1执行第6行代码，
对i进行加1得到的结果是2然后赋回给i。好了，问题出来了，我们清楚的直到循环进行了两次，按正常逻辑来说，对i进行两次加1操作后，此时i应该等于3，
但是两条线程完成两次加1操作后i的值竟然是2，当进行第三次循环的时候，读取到i的值将会是2，这样的结果是不是很诡异，这就是线程安全问题的产生。
那么引发这个问题的原因是什么呢？其实就是将读和写进行了分割，当读和写分割开后，如果一条线程读完但未写时被CPU停掉，
此时其他线程就有可能趁虚而入导致最后产生奇怪的数据。

那么上面这段代码怎么修改才能不产生线程安全问题呢？我们知道一条线程被CPU调度执行任务时，最少要执行一行代码，所以解决办法很简单，
只要将读和写合并到一起就可以了，下面的代码是通过JUC中的原子操作来完成自增的操作（
不熟悉的同学可以简单的将其理解成读写是一起执行的，不可以被分开执行）：

1 private static AtomicInteger count = new AtomicInteger(0);
2
3 while(count < 10){
4    count.incrementAndGet();
5 };
这样，我们将读和写用原子操作count.incrementAndGet()来替代，此时线程无论在哪行停止，其他线程也不会对数据产生干扰，
我画一个图来形象的说明这一点（图有点丑，不要介意）：
我们可以把左边的圆看成是符合原子性（即一步执行）的代码，而右边的圆是被分割成了两步执行的代码。如果数据没有破坏原子性，由于线程被调度一次的最少要执行1行代码，那么t1只要执行了这行代码，就会连读带写全部完成，其他线程再拿到的数据就是被写过的最新数据，不会有任何安全隐患；而如果数据破坏了原子性，将读写进行了分割，那么t1，读取完数据如果停掉的话，t2执行的时候拿到的就是一个老数据（没有被更新的数据），接下来t1,t2同时对相同的老数据进行更新势必会因此数据的异常。

另外需要说明的是，为什么上面我要使用JUC的AtomicInteger类而不是count++？这里涉及到了一个经典的面试题，count++操作是否是线程安全的？答案是不是，有兴趣的同学可以参考https://blog.csdn.net/moakun/article/details/81149254

2.注意
　　对于线程安全问题，需要注意以下两点：

只存在读数据的时候，不会产生线程安全问题。
在java中，只有同时操作成员（全局）变量的时候才会产生线程安全问题，局部变量不会（每个线程执行时将会把局部变量放在各自栈帧的工作内存中，线程间不共享，故不存在线程安全问题，这里不展开描述内存问题，有兴趣可自行百度）。