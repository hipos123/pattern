一，工厂模式（小作坊------》工厂---------》流水线）
先说下工厂模式的特性
1.对于调用者来说，影藏了复杂的逻辑处理过程，调用者只关心执行结果。
2.工厂要对结果负责，保证生产出符合规范的产品。

1，简单工厂模式：最早以前小作坊的方式进行生产。
扩展性差，增加任何一种牛奶厂商，都得修改简单工厂，新增对应的实现类。代码之间的耦合性特别大，不论是新增还是修改，都得
对simpleFactory这个类进行修改，代码侵入性特别大。而且对于消费者来说，进行调用的时候，还得传入正确的参数，否则就会调用出错。

2，方法工厂模式：
在一定程度上解耦并且增加了扩展性，后续如果有新的工厂新增，只需要实现工厂接口就可以。各个工厂都是独立的，不会存在一定的
业务耦合。各个工厂的修改，对于消费者而且是无感知的。消费者进行调用的时候，只需要知道自己需要哪个实现类即可。

3，抽象工厂模式：
抽象工厂模式，他只留给了消费者的选择权。对于消费者而言，所有工厂内部实现的东西，对于消费者而言都是无感知的。
他和方法工厂模式，方法模式还需要知道需要调用哪个实现类，抽象工厂模式，只需要消费者选择哪个一个类。
而且在抽象类中，还可以实现一堆统一的方法供其调用。


（扩展：类加载的顺序：先静态后动态，先属性后方法，先上后下）

二，单例模式：一个类模板在整个系统运行中，有且只有一个实例，只允许new一个对象。
比如：配置文件，日期，ioc容器(只允许有一个配置文件，多个的话都不知道以哪个为准)
保证单例的技术方案有很多种：饿汉式，懒汉式，注册登记式，枚举式，（序列化和反序列化的时候出现多例）

饿汉式：在实例使用之前，不管你用还是不用，都先new出来再说，避免了线程安全问题。
优点：没有任何的锁，执行效率较高，用户体验上来说，比懒汉式更好。
缺点:类加载的时候就初始化了，不管你用不用，都占用着空间。浪费着内存。


懒汉式：在默认加载的时候不需要实例化，用到的时候才需要实例化。动态产生的实例，会有线程安全问题。
为了解决懒汉式的线程安全问题，在生产实例的方法上加了synchronize 同步锁。但是导致了性能非常低下（比较大的同步线程操作的情况下）。
为了解决这个问题，出现了内部类

内部类（懒汉模式）：内部类只有被外部类调用的时候才会被加载。兼顾了饿汉式的内存浪费，也兼顾了懒汉式的synchronize问题。
反射入侵问题？

注册式单例：spring就是用这种注册式单例来获取bean的。beanFactory

https://www.cnblogs.com/twoheads/p/9723543.html
为什么spring使用注册式单例，而不使用其他的单例模式。由于其他的单例模式，构造函数都是私有的，没办法被子类继承（子类继承父类，父类的构造函数不能是私有的，如果父类的构造函数私有化
，那么子类在初始对象的时候，就没办法初始化了。但是注册式单例，父类的构造函数不是私有的，可以被子类继承，所以spring使用它）



三，原型模式：
浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。
深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。
原型模式的使用场景：
1，在需要一个类的大量对象的时候，使用原型模式是最佳的选择，因为原型模式是在内存中对对象进行拷贝，要比new这个对象性能要好的对。
在这种场景下，需要的对象越多，原型模式提现的优点越明显
2，如果一个对象的初始化需要其他很多对象的数据准备或者其他资源的计算，那么原型模式就很适合去拷贝一个对象。
3，当需要一个对象的大量信息，少量属性需需要个性化设置的情况下，可以使用原型模式拷贝出一个副本，然后再对副本进行加工处理。
https://www.cnblogs.com/pypua/p/11378158.html

四，代理模式
代理模式的作用：aop实现，拦截，中介，黄牛，媒婆，解耦，专人做专事，自己不想做但又不得不做的事情

代理模式的特点是：客户端并没有直接和实际的对象接触（没有直接调用），而是通过代理类去操作，在这期间代理类做了很多额外的工作，而最终的结果又是客户端实际需要的结果。借用
代理类的手，间接的调用实际的对象。

代理分为静态代理和动态代理
静态代理的特点：代理类得根据客户的要求，不断的调整客户的需求。或者为每个服务创建一个代理类，工作太大，不易管理。同时接口发生变化，代理类也要改变。

动态代理的特点：在动态代理中我们不再需要再手动的创建代理类，我们只需要编写一个动态处理器就可以了。真正的代理对象由JDK再运行时为我们动态的来创建





五，策略模式







