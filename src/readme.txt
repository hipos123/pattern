一，工厂模式（小作坊------》工厂---------》流水线）
1，简单工厂模式：最早以前小作坊的方式进行生产。
扩展性差，增加任何一种牛奶厂商，都得修改简单工厂，新增对应的实现类。代码之间的耦合性特别大，不论是新增还是修改，都得
对simpleFactory这个类进行修改，代码侵入性特别大。而且对于消费者来说，进行调用的时候，还得传入正确的参数，否则就会调用出错。

2，方法工厂模式：
在一定程度上解耦并且增加了扩展性，后续如果有新的工厂新增，只需要实现工厂接口就可以。各个工厂都是独立的，不会存在一定的
业务耦合。各个工厂的修改，对于消费者而且是无感知的。消费者进行调用的时候，只需要知道自己需要哪个实现类即可。

3，抽象工厂模式：
抽象工厂模式，他只留给了消费者的选择权。对于消费者而言，所有工厂内部实现的东西，对于消费者而言都是无感知的。
他和方法工厂模式，方法模式还需要知道需要调用哪个实现类，抽象工厂模式，只需要消费者选择哪个一个类。
而且在抽象类中，还可以实现一堆统一的方法供其调用。


（扩展：类加载的顺序：先静态后动态，先属性后方法，先上后下）

二，单例模式：一个类模板在整个系统运行中，有且只有一个实例，只允许new一个对象。
比如：配置文件，日期，ioc容器(只允许有一个配置文件，多个的话都不知道以哪个为准)
保证单例的技术方案有很多种：饿汉式，懒汉式，注册登记式，枚举式，（序列化和反序列化的时候出现多例）

饿汉式：在实例使用之前，不管你用还是不用，都先new出来再说，避免了线程安全问题。
优点：没有任何的锁，执行效率较高，用户体验上来说，比懒汉式更好。
缺点:类加载的时候就初始化了，不管你用不用，都占用着空间。浪费着内存。


懒汉式：在默认加载的时候不需要实例化，用到的时候才需要实例化。动态产生的实例，会有线程安全问题。
为了解决懒汉式的线程安全问题，在生产实例的方法上加了synchronize 同步锁。但是导致了性能非常低下（比较大的同步线程操作的情况下）。
为了解决这个问题，出现了内部类

内部类（懒汉模式）：内部类只有被外部类调用的时候才会被加载。兼顾了饿汉式的内存浪费，也兼顾了懒汉式的synchronize问题。
反射入侵问题？

注册式单例：spring就是用这种注册式单例来获取bean的。beanFactory



